# Варианты исполнения кода на python

1. Интерактивный вариант (консоль Python/Shell)
IDLE - и есть интерактивый вариант. В нем каждая инструкция исполняется моментально 

2. Файловый вариант (стандартный вариант)

# Знакомство с объектами в python

Программа - это набор инструкций, которая описывает компьютеру определенную последовательность действий. 

Программа состоит из инструкций. В свою очередь каждая инструкция создает или обрабатывает объекты. 

Встроенные типы объектов Python

![типы объектов](img/Типы объектов)

Функция type() позволяет узнать тип объекта

## Числа и операции над ними

### integer

Целое число - число, не содержащее дробной части.

Целые числа - все отрицательные числа, положительные и ноль. 

Функция для преобразования в тип integer - int()

### float

вещественные числа (числа с плавающей точкой) отличаются от целых наличием *дробной части*

Пример: 7.6, 8.0, -5.5

Целая часть отделяется от дробной знаком "точки". 

Функция float() - преобразует данные в вещественный тип. 

### Основные операции

![операции](img/операции)

Тонкости в операциях: 
- 2%7 = 2 (7\*0+2(!))
- любые операции с вещественным числом возвращают вещественное число 

![приоритеты](img/приоретиты)

Некоторые встроенные функции по работе с числами: 
![встроенне операции](img/встроенные)

abs - модуль. функция, которая отбрасывает знак
pow - возводит первое значение в степень второго
round - округление до целого числа ( round(число, до какого разряда)), можно задавать отриц значения, тем самым, например, округлив по десятки. при этом 3.5 -> 4

![разряды](img/разряды)

Все математические функции находятся в модуле math.

# Переменные в питоне. Оператор присваивания. 

Переменная - именованная область памяти, предназначенная для хранения значения. 
= - оператор присваивания. 

Чтобы создать переменную, нужно положить в нее значение. То есть они создаются в момент первого их присваения. 

![переменная](img/переменная)

Переменная должна начинаться с буквы или нижнего подчеркивания. Питон чувствителен к регистру букв. Также переменные не могут иметь зарезервированное слово в качестве идентификатора. 

Имена функций можно использовать в качестве идентификаторов, но возможность вызова этих функция потеряется. 

Создание переменной: 
а = 4
Есть список переменных и список объектов. 

- Создается объект целого типа со значением 4 
- Затем проверится есть ли переменная а. если нет, то она создается. 
- в переменной а сохранится ссылка на объект. 
Если мы присвоим переменной новое значение то:
- создастся объект вещественного типа со значением 5.4 
- Переменная а уже существует
- В переменную а сохранится новая ссылка, при том старая пропадет.

Динамическая типизация - переменные могут принимать значения любых типов. 

![присваивание](img/присваивание)

Массовое присваение: a=b=c=1
Множественные присваения: a, b = 2, 7 

# Ввод и вывод данных в питоне. 

Функция input() - считывает значения, которые пользователь вводит в консоль и возвращает его. 

Функция print() - выводит переданные ей значения. 

У нее есть параметр - sep (separate-разделять, separator - разделитеть). По умолчанию он равен пробелу. Чтобы изменить это поведение, нужно последним аргументом указать значение sep='' на произвольную строку, которая будет в качестве разделителя.

Также есть параметр end, который отвечает за то, что будет выводиться после всех значений, в конце. end='\n' - по умолчанию. Передав end новую строку, можно изменить его поведение. 

%s - специальный параметр, который указывается в строке, чтобы подставить туда значения из переменных. 
![процент](img/процент)

# Деление нацело и остаток от деления

Если любое число %10 - получим последнюю цифру

**любое число % (10 \*\* n) ** где n - сколько цифр хотим взят с конца. 

Если любое число //10 - уберем последнюю цифру 

**любое число // (10 \*\* n))** - где n - сколько цифр с конца нужно убрать 

# Функции trunc, floor, ceil

Все эти функции находятся в модуле math. 
trunc() - отсекает дробную часть. 
int() - тоже в процессе прообразования отсекает дробную часть. 
floor() - округление вниз. Наибольшее целое число, которое не превосходит нашего вещественного числа. 
ceil() - округление вверх. Наименьшее целое число, которое превосходит наше вещественное число. 
ceil() и floor() возвращают целые числа. 

# Логический тип bool. Операторы сравнения 

![сравнение](img/сравнение)

x%2==0 : True - четное, False - нечетное

x%n==0 : кратность, где x - число, которое кратно n. True - кратно, False - нет. 
x%n!=0 : некратность n. так же можно записать с помощью not x%4==0 

**and, or, not** 

bool() - функция преобразования в bool (любое непустое значение преобразуется в True)

# Строки и операции над ними

строки - ' ' или " "'
Многострочные строки - ''' ''' 


\n - перенос строки 
\t - табуляция 

'string' + 'second_string' - 'stringsecond_string' (конкатенация строк)
"a" * 5 - 'aaaaa' (умножение строк)

str() - преобразование в тип str

len() - длина строки, возвращает тип int 

с помощью **in** можно проверить есть ли какая то подстрока в нашей строке. 

Питон сравнивает строки посимвольно по коду букв. 'r'>'abc'
Числовое значение буквы можно получить с помощью функции ord().
Эти коды можно загуглить - ascii code table 

## Индексы и срезы 

Строка - **упорядоченная** коллекция символов. 
То есть каждый символ имеет свой индекс. 

Чтобы обратиться к каким либо символам строки через индекс, нужно указать его в []. 
строка[номер индекса]
'Hello'[1] -> e

string[len(string)-1] - чтобы получить последнюю букву. ИЛИ string[-1]

Срез - строка[С какого индекса брать:ДО какого брать]
В срезе можно не указывать один из индексов (правый или левый): 
string[4:] - с 4 до конца
string[:6] - с начала ДО 6
string[:] - вся строка 
Чтобы указать шаг нужно: string[::шаг]

Строка *неизменяемый* объект - то есть присвоить значение по индексу не получится. 
Но можно создать новую строку с помощью срезов и конкатенации. 

## Методы строк 

Метод - функция, которая связана с определенным типом объекта. То есть методы являются специфичными для каждого отдельного типа. 

Вызов метода: объект.метод(аргументы)

**Также есть цепочки вызовов методов: ** объект.метод().метод().метод()

s.upper() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы заглавные
s.lower() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы строчные

s = s.upper() - чтобы сохранить изменения

s.count('str', [начальный индекс, [конечный индекс]]) - подсчитывает сколько раз встретилась подстрока 'str' в строке s

s.find('str', [начальный индекс, [конечный индекс]]) - ищет индекс подстроки 'str'
s.rfind('str') - ищет индекс подстроки 'str' с конца

s.index('str') - возвращает индекс указанной подстроки
s.replace('o', '', количество замен) -  заменяет подстроку на другую (можно убрать пробелы в строке или удалить некоторые буквы)
s.isalpha() - возвращает True, если строка состоит целиком из букв
s.isdigit() - возвращает True, если строка состоит целиком из цифр
s.rjust(n, 'ОДИН символ заполнителя') - строка "прижимается" к правому краю и следовательно ПЕРЕД ним добавляется некоторое количество знаков заполнителя до того момента, когда длина строки будет равна n.  
s.ljust()

s.split('разделитель') - Разбивает строку по пробелам (по разделителям) и добавляет подстроки в список. 
![сплит](img/сплит)
связующий знак(разделитель).join(список строк)
![джоин](img/джоин )

s.strip() - удаляет знаки пробелов и служебные знаки(переносы строк)
s.rstrip() - удаляет справа знаки пробелов и служебные знаки(переносы строк)
s.lstrip() - удаляет слева знаки пробелов и служебные знаки(переносы строк)

# Форматирование строк

## метод format

Позиционное форматирование строк: 
print('text {0} text text {1} text text text {2}').format(value1, value2, value3) 
переменные в аргументе метода format нумеруются от 0 до n. Эти номера подставляются в строку в фигурных скобках. 

Именованное форматирование строк: 
a, b, c = 1, 2, 3
print('text {value1} text text {value2} text text text {value3}').format(value1=a, value2=b, value3=c) 

## f-строки

a, b = 1, 2
print(f'text {a.lower()} text text {b\*2} text {abs(-45)} text') - нужно поставить перед форматируемой строкой букву f и заключить названия переменных или инструкции в строке в фигурные скобки. 

# Списки и операции над ними

Список - упорядоченная коллекция элементов. Они позволяют хранить взаимосвязанные данные. 

[элемент, элемент, элемент] - список
Элементы могут быть любых типов.

len() - возвращает количество элементов в коллекции.

Сцепление списков: 
[a, b] + [c ,d] = [a, b, c, d]

Добваить элемент в конец: 
список = список + другой список

Добавить элемент в конец: 
список = другой список + список

Дублирование списков: 
[1, 2, 3] * 2 = [1, 2, 3, 1, 2, 3]

a = 'Hello'
list(a) -> ['H', 'e', 'l', 'l', 'o']

Проверка вхождения: 
значение in список -> True или False 

Если список состоит целиком из чисел, то вы можете:
max()
min()
sum()

sorted(список) - возвращает отсортированный список по возрастанию (по умолчанию)
Параметры: reverse=True - по убыванию 

Сравнение списков: 
Списки сравниваются поэлементно, то есть [3] > [2, 3, 1] -> True
список == список -> True , если в списке одинаковое количестко идентичных элементов. 

Среднее арифметическое списка: 
sum(список)/len(список)

**Распокование переменных **
a = [1, 2, 3]
b, c, d = a -> b = 1, c = 2, d = 3



